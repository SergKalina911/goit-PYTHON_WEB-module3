"""Блокування

​Для цього є механізм блокування. У Python є два примітива блокувань: Lock та RLock. Lock трохи 
швидший і більш низькорівневий, але він не рекурсивний і може бути ситуація потрапляння в DeadLock, 
коли виконання коду заблокується, кілька потоків чекатимуть, доки хтось віддасть Lock, а його ніхто 
ніколи вже не віддасть. Це і є ситуація, коли програма "зависла".
RLock трохи повільніший, зате виключає взаємне блокування. Рекомендується завжди використовувати 
саме його, якщо немає вагомих причин використовувати Lock."""

from threading import Thread, RLock
import logging
from time import time, sleep

lock = RLock()


def func(locker, delay):
    """Функція, яка виконується в окремому потоці."""
    # using acquire() and release()
    timer = time()
    locker.acquire()
    sleep(delay)
    locker.release()
    # alternatively, using context manager
    logging.debug(f'Done {time() - timer}')


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG, format='%(threadName)s %(message)s')
    # початок двох потоків, які використовують один lock
    t1 = Thread(target=func, args=(lock, 2))
    t2 = Thread(target=func, args=(lock, 2))
    t1.start()
    t2.start()
    logging.debug('Started')


# У цьому прикладі ми запустили два потоки і один загальний RLock. У консолі ви побачите:
# MainThread Started
# Thread-1 Done 2.0003550052642822
# Thread-2 Done 4.000735521316528

# Таке виведення означає, що один із потоків "взяв" lock і поки він його не "відпустив", інший 
# чекав доки lock 
# звільниться. Блокування ресурсу досягається виконанням команди locker.acquire(). Це робиться, 
# щоб загальним 
# ресурсом міг користуватися лише один потік на один момент часу, і лише коли потік закінчить 
# роботу із загальним 
# ресурсом, він відпускає lock, у нашому випадку команда locker.release(), і хтось інший зможе 
# попрацювати з 
# ресурсом. Так гарантується, що загальний ресурс не потрапить у невизначений стан, коли хтось 
# почав із ним роботу 
# та не закінчив, а хтось інший почав, і так далі.
# Зверніть увагу, що якщо у вас є кілька блокувань, то завжди намагайтеся їх "брати" в одному й 
# тому ж порядку,
# інакше ви ризикуєте потрапити в DeadLock.
# Використання RLock дозволяє уникнути ситуації DeadLock, коли один і той же потік може "взяти" 
# lock кілька разів
# підряд, не викликаючи блокування самого себе.

