"""                                     Заняття 1: Багатопоточність у Python


                                        Вступ до багатопотоковості



                        Сфера застосування

​Що робить застосунок, доки чекає відповіді від сервера або чекає, доки файл прочитається із жорсткого диска? 
Зазвичай у такі моменти застосунок нічого не робить і просто чекає на результат операції. Це не є проблемою, 
тільки, якщо вам не потрібно прискорити роботу вашого застосунку. Особливо це критично для ситуацій, коли 
застосунок робить багато дуже схожих блокуючих викликів (запитів на віддалений сервер, операцій читання/запису 
файлів). У такі моменти, звичайно, хочеться оптимізувати роботу застосунку та виконувати кілька блокуючих 
операцій паралельно. Код, що виконує паралельно кілька завдань, називається асинхронним. Найпростіший спосіб 
реалізувати асинхронність — це виконувати завдання в окремих потоках всередині одного процесу.

Процес — область пам'яті (віртуальна) + набір ресурсів + 1 і більше потоків.

Потік — послідовність інструкцій та системних викликів всередині процесу.

Всі потоки мають доступ до всіх ресурсів свого процесу. Усі процеси ізольовані один від одного, і будь-яка 
міжпроцесна взаємодія відбувається тільки через операції введення/виведення (системні виклики).



                        IO and CPU bound tasks

​Завдання, які виконують операції введення/виведення (читання/запис файлів, запити в мережі тощо), називаються 
IO (Input Output)-bound завданнями. Домогтися паралелізму виконання IO завдань у Python можна, використовуючи 
потоки.

Однак потрібно пам'ятати, що асинхронний код завжди на порядок складніший для розуміння та відлагодження. Для 
багатопотокових застосунків складно писати тести та складно перевіряти всілякі ситуації, які відбуваються рідко 
та залежать від порядку викликів у різних потоках. Загальне правило для програмування будь-якою мовою: якщо є 
можливість обійтися синхронним кодом, то так і потрібно зробити.

Інший тип блокуючих викликів — це важкі з точки зору обчислень операції.

Реальний застосунок завжди повинен якимось чином реагувати на дії користувача і, якщо ваш застосунок під час 
виконання складних обчислень перестає відповідати на запити, то користувач може вирішити, що застосунок просто 
завис. Виходить, що для зручності користувача застосунок повинен відповідати на запити, навіть коли робить якісь 
складні та довгі обчислення.

Такі завдання називаються CPU-bound завданнями. Як і для IO-bound завдань, можна винести виконання блокуючих 
операцій (складних обчислень) в окремий потік, щоб застосунок продовжував взаємодіяти з користувачем, здійснюючи 
обчислення.

Загалом, операційна система передає управління потокам (як і передача управління процесами). Це означає, що 
будь-якої миті, перед будь-яким викликом ОС (Операційна Система) може призупинити виконання коду потоку та 
розпочати виконувати код іншого потоку, щоб потім так само далі призупинити і його для передачі управління.

До появи багатоядерних процесорів справжній паралелізм був неможливим. Звичайно, коли управління передається 
різним потокам по кілька тисяч разів на секунду, з погляду користувача це виглядає як паралельне виконання кількох 
завдань. У сучасних процесорах зазвичай є мінімум два ядра і тепер ми можемо писати код, який виконується справді 
паралельно. Це з однієї сторони додає можливостей, але й додає складнощів, оскільки тепер потрібно бути ще 
уважнішими при написанні асинхронного коду, адже припуститися помилки ще простіше.

Гарна стаття про асинхронний код. https://medium.com/swift-india/concurrency-parallelism-threads-processes-async-and-sync-related-39fd951bc61d


                        Global Interpreter Lock (GIL)

​Потоки можуть виконуватися дійсно паралельно (якщо ядер процесора більше 1), процеси — тим більше. Але у Python є 
механізм, який примусово блокує виконання коду різними потоками одного Python процесу в один і той самий час.

    1. Тільки один потік всередині процесу Python виконується, всі інші (якщо такі є) знаходяться в режимі 'Sleep'.
    2. Операції, пов'язані з введенням/виведенням (системні виклики) не блокуються GIL, але не їх послідовність.

Це означає, що якщо ви зробите кілька IO викликів у різних потоках, то вам не гарантується черговість завершення 
цих потоків, але гарантується, що коли виконується код будь-якого з потоків, всі інші потоки чекають черги і 
нічого не роблять. Це буде так, навіть якщо код виконується на сучасному процесорі з кількома ядрами


            Чому в Python є GIL?

    1. Простий і зрозумілий збирач сміття.
    2. Виключає можливість одночасного доступу до ресурсів/пам'яті. Немає потреби враховувати особливості 
    конкретної ОС для обробки таких ситуацій.
    3. Це спадщина епохи одноядерних процесорів, коли додаткові потоки/процеси уповільнювали виконання програми.

Python розроблявся в епоху одноядерних процесорів і навіть теоретично ніхто тоді не міг припустити дійсне 
одночасне виконання коду в різних потоках. Через це було зроблено низку архітектурних рішень, які вже не змінити, 
і на Python накладено обмеження GIL.


            Як обійти GIL:

    1. Написати частину коду, яку потрібно запускати паралельно, на Cython і використовувати потоки.
    2. Використовувати Multiprocessing.


            Чому не потрібно цього робити:

    1. Python — скриптова мова і швидкість роботи не її сильна сторона. Якщо потрібна швидкість, то, можливо, є 
    сенс розглянути інший інструмент.
    2. Створення процесів використовує деяку кількість ресурсів системи (пам'ять та процесорний час).
    3. Перемикання між процесами також використовує процесорний час.


                                        Створення потоків у Python


Документація про доступні в Python механізми написання потокового коду.
https://docs.python.org/3/library/concurrency.html


                        Потік як клас

​Щоб створити потік, найпростіше імпортувати клас Thread з модуля threading і наслідуватись від цього класу. Далі 
вам потрібно визначити метод run у вашого класу, цей метод буде виконуватись в окремому потоці. Щоб розпочати 
виконання коду в окремому потоці, потрібно викликати метод start, який визначений у Thread. Давайте напишемо клас 
MyThread, що в окремому потоці спить вказаний час і після цього виводить у консоль 'Wake up!':
"""

from threading import Thread
import logging
from time import sleep


class MyThread(Thread):
    def __init__(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None):
        super().__init__(group=group, target=target, name=name, daemon=daemon)
        self.args = args
        self.kwargs = kwargs

    def run(self) -> None:
        sleep(2)
        logging.debug('Wake up!')
        logging.debug(f"args: {self.args}")


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG, format='%(threadName)s %(message)s')
    for i in range(5):
        thread = MyThread(args=(f"Count thread - {i}",))
        thread.start()
    print('Usefull message')


"""
Якщо виконати цей скрипт, то в консолі ви побачите:

Usefull message
Thread-5 Wake up!
Thread-5 args: ('Count thread - 4',)
Thread-3 Wake up!
Thread-3 args: ('Count thread - 2',)
Thread-2 Wake up!
Thread-2 args: ('Count thread - 1',)
Thread-1 Wake up!
Thread-1 args: ('Count thread - 0',)
Thread-4 Wake up!
Thread-4 args: ('Count thread - 3',)

Це означає, що основний потік застосунку спочатку вивів 'Usefull message' і після нього через 2 секунди п'ять 
потоків MyThread вивели своє 'Wake up!', і тільки після цього скрипт завершився.


                        Потік як функтор

​Є інший спосіб виконати код окремого потоку. Для цього потрібно, щоб код виконання був функтором (функцією або 
класом, який має метод __call__). Тоді об'єкт можна передати як іменований аргумент target у Thread:
"""

from threading import Thread
from time import sleep
import logging


class UsefulClass():
    def __init__(self, delay_time):
        self.delay = delay_time

    def __call__(self):
        sleep(self.delay)
        logging.debug('Wake up!')


if __name__ == '__main__':
    logging.basicConfig(level=logging.DEBUG, format='%(threadName)s %(message)s')
    t2 = UsefulClass(2)
    thread = Thread(target=t2)
    thread.start()
    print('Some stuff')

# Результат:
# Some stuff
# Thread-1 Wake up!

""" """