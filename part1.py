"""                                     Заняття 1: Багатопоточність у Python


                                        Вступ до багатопотоковості



                        Сфера застосування

​Що робить застосунок, доки чекає відповіді від сервера або чекає, доки файл прочитається із жорсткого диска? 
Зазвичай у такі моменти застосунок нічого не робить і просто чекає на результат операції. Це не є проблемою, 
тільки, якщо вам не потрібно прискорити роботу вашого застосунку. Особливо це критично для ситуацій, коли 
застосунок робить багато дуже схожих блокуючих викликів (запитів на віддалений сервер, операцій читання/запису 
файлів). У такі моменти, звичайно, хочеться оптимізувати роботу застосунку та виконувати кілька блокуючих 
операцій паралельно. Код, що виконує паралельно кілька завдань, називається асинхронним. Найпростіший спосіб 
реалізувати асинхронність — це виконувати завдання в окремих потоках всередині одного процесу.

Процес — область пам'яті (віртуальна) + набір ресурсів + 1 і більше потоків.

Потік — послідовність інструкцій та системних викликів всередині процесу.

Всі потоки мають доступ до всіх ресурсів свого процесу. Усі процеси ізольовані один від одного, і будь-яка 
міжпроцесна взаємодія відбувається тільки через операції введення/виведення (системні виклики).



                        IO and CPU bound tasks

​Завдання, які виконують операції введення/виведення (читання/запис файлів, запити в мережі тощо), називаються 
IO (Input Output)-bound завданнями. Домогтися паралелізму виконання IO завдань у Python можна, використовуючи 
потоки.

Однак потрібно пам'ятати, що асинхронний код завжди на порядок складніший для розуміння та відлагодження. Для 
багатопотокових застосунків складно писати тести та складно перевіряти всілякі ситуації, які відбуваються рідко 
та залежать від порядку викликів у різних потоках. Загальне правило для програмування будь-якою мовою: якщо є 
можливість обійтися синхронним кодом, то так і потрібно зробити.

Інший тип блокуючих викликів — це важкі з точки зору обчислень операції.

Реальний застосунок завжди повинен якимось чином реагувати на дії користувача і, якщо ваш застосунок під час 
виконання складних обчислень перестає відповідати на запити, то користувач може вирішити, що застосунок просто 
завис. Виходить, що для зручності користувача застосунок повинен відповідати на запити, навіть коли робить якісь 
складні та довгі обчислення.

Такі завдання називаються CPU-bound завданнями. Як і для IO-bound завдань, можна винести виконання блокуючих 
операцій (складних обчислень) в окремий потік, щоб застосунок продовжував взаємодіяти з користувачем, здійснюючи 
обчислення.

Загалом, операційна система передає управління потокам (як і передача управління процесами). Це означає, що 
будь-якої миті, перед будь-яким викликом ОС (Операційна Система) може призупинити виконання коду потоку та 
розпочати виконувати код іншого потоку, щоб потім так само далі призупинити і його для передачі управління.

До появи багатоядерних процесорів справжній паралелізм був неможливим. Звичайно, коли управління передається 
різним потокам по кілька тисяч разів на секунду, з погляду користувача це виглядає як паралельне виконання кількох 
завдань. У сучасних процесорах зазвичай є мінімум два ядра і тепер ми можемо писати код, який виконується справді 
паралельно. Це з однієї сторони додає можливостей, але й додає складнощів, оскільки тепер потрібно бути ще 
уважнішими при написанні асинхронного коду, адже припуститися помилки ще простіше.

Гарна стаття про асинхронний код. https://medium.com/swift-india/concurrency-parallelism-threads-processes-async-and-sync-related-39fd951bc61d


                        Global Interpreter Lock (GIL)

​Потоки можуть виконуватися дійсно паралельно (якщо ядер процесора більше 1), процеси — тим більше. Але у Python є 
механізм, який примусово блокує виконання коду різними потоками одного Python процесу в один і той самий час.

    1. Тільки один потік всередині процесу Python виконується, всі інші (якщо такі є) знаходяться в режимі 'Sleep'.
    2. Операції, пов'язані з введенням/виведенням (системні виклики) не блокуються GIL, але не їх послідовність.

Це означає, що якщо ви зробите кілька IO викликів у різних потоках, то вам не гарантується черговість завершення 
цих потоків, але гарантується, що коли виконується код будь-якого з потоків, всі інші потоки чекають черги і 
нічого не роблять. Це буде так, навіть якщо код виконується на сучасному процесорі з кількома ядрами


            Чому в Python є GIL?

    1. Простий і зрозумілий збирач сміття.
    2. Виключає можливість одночасного доступу до ресурсів/пам'яті. Немає потреби враховувати особливості 
    конкретної ОС для обробки таких ситуацій.
    3. Це спадщина епохи одноядерних процесорів, коли додаткові потоки/процеси уповільнювали виконання програми.

Python розроблявся в епоху одноядерних процесорів і навіть теоретично ніхто тоді не міг припустити дійсне 
одночасне виконання коду в різних потоках. Через це було зроблено низку архітектурних рішень, які вже не змінити, 
і на Python накладено обмеження GIL.


            Як обійти GIL:

    1. Написати частину коду, яку потрібно запускати паралельно, на Cython і використовувати потоки.
    2. Використовувати Multiprocessing.


            Чому не потрібно цього робити:

    1. Python — скриптова мова і швидкість роботи не її сильна сторона. Якщо потрібна швидкість, то, можливо, є 
    сенс розглянути інший інструмент.
    2. Створення процесів використовує деяку кількість ресурсів системи (пам'ять та процесорний час).
    3. Перемикання між процесами також використовує процесорний час.




"""