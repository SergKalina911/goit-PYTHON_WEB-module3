""" Черги

Клас JoinableQueue - це розширення звичайної черги (Queue) в Python, яке дозволяє 
відстежувати, коли всі елементи в черзі були оброблені. Це особливо корисно в 
багатопоточних або багатопроцесорних програмах, де кілька робітників можуть обробляти 
завдання з черги.

У наступному прикладі master-процес (основний процес) очікує виконання завдань від робочих 
процесів за допомогою виклику методу jq.join() у екземпляра черги JoinableQueue. Самі 
worker-процеси повідомляють master про успішне виконання завдання через виклик методу 
черги jqueue.task_done(). Це дозволяє тримати в курсі master-процес про стан завершення 
робочого процесу та рядок коду print('Finished') виконається тільки тоді, коли всі робочі 
процеси будуть завершені."""

from multiprocessing import JoinableQueue, Process, current_process
from time import sleep
import sys
import logging

logger = logging.getLogger()
stream_handler = logging.StreamHandler()
logger.addHandler(stream_handler)
logger.setLevel(logging.DEBUG)
# Створюємо чергу для обміну даними між процесами JoinableQueue, яка дозволяє
# відстежувати виконання завдань робочими процесами та повідомляти master-процес
# про їх завершення. Це дозволяє синхронізувати роботу між master-процесом та
# робочими процесами, гарантуючи, що master-процес буде знати, коли всі завдання
# були викон ані, і може виконувати подальші дії, такі як виведення повідомлення
# про завершення роботи. Використання JoinableQueue забезпечує ефективну комунікацію
# та координацію між процесами в багатопроцесорних програмах.
jq = JoinableQueue()


def worker(jqueue: JoinableQueue):
    """Процес-робітник, що бере завдання з черги і виконує їх."""

    # Отримуємо ім'я процесу для логування й повідомляємо про старт робітника
    name = current_process().name
    logger.debug(f'{name} started...')
    # Читаємо завдання з черги і виконуємо його (підносимо до квадрату) та
    # повідомляємо master-процес про завершення завдання через виклик методу
    # task_done() черги JoinableQueue. Це дозволяє master-процес відстежувати
    # стан виконання завдань і виконувати подальші дії, коли всі завдання будуть
    # завершені.
    val = jqueue.get()
    logger.debug(f'{name} {val**2}')
    sleep(1)
    jqueue.task_done()
    # Завершуємо процес робітника через виклик sys.exit(0), що сигналізує про успішне
    # завершення процесу. Це дозволяє master-процес відстежувати стан виконання робочих
    # процесів і виконувати подальші дії, коли всі робочі процеси будуть завершені.
    sys.exit(0)


if __name__ == '__main__':
    # Створюємо процеси-робітники, які будуть виконувати завдання з черги JoinableQueue.
    # Кожен процес-робітник отримує посилання на чергу JoinableQueue через аргументи функції
    # worker, що дозволяє їм взаємодіяти з чергою для отримання завдань та повідомлення про
    # їх виконання.

    w1 = Process(target=worker, args=(jq, ))
    w2 = Process(target=worker, args=(jq, ))
# Запускаємо процеси-робітники, що дозволяє їм почати виконання завдань з черги JoinableQueue.
    w1.start()
    w2.start()
# Кладемо завдання у чергу JoinableQueue, що дозволяє робочим процесам отримувати ці завдання
# та виконувати їх. Виклик методу put() додає завдання до черги, а виклик sleep(1) забезпечує
# затримку між додаванням завдань, що може бути корисно для імітації реального часу обробки
# завдань. Після додавання завдань до черги, виклик методу join() на черзі JoinableQueue дозволяє
# master-процес очікувати, поки всі завдання в черзі будуть оброблені робочими процесами.
# Це забезпечує синхронізацію між master-процесом та робочими процесами, гарантуючи, що рядок
# коду print('Finished') буде виконаний тільки після того, як всі робочі процеси завершать
# обробку завдань.
    jq.put(8)
    sleep(1)
    jq.put(16)
    jq.join()
    print('Finished')

# Виведення
# Process-2 started...
# Process-2 64
# Process-1 started...
# Process-1 256
# Finished
